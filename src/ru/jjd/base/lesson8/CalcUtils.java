package ru.jjd.base.lesson8;

public final class CalcUtils {
    //оператор final - если используем для класса, то запрещаем наследовать от него
    //значения свойств объявленных как final должны быть установлены либо сразу при объявлении, либо в конструкторе
    //значения final свойств нельзя изменить
    //константы описываются буквами в верхнем регистре, через подчеркивания
    final double PI = 3.14;

    //final методы нельзя переопределять в классах-наследниках
    //final аргументы в методе доступны только для чтения
    public final void someVoid(final int num, final SomeClass sc, final int[] arr){
        System.out.println(num);
        //num = 90; - выдаст ошибку, нельзя менять аргументы final
        System.out.println(sc);
        System.out.println(sc.name);
        sc.name = "Новое имя";//свойства объекта final доступны для изменения
        //sc = new SomeClass(); сам объект final менять нельзя, но свойства его изменять можно
        arr[4] = 34;//в final любой элемент массива доступен для изменения, сам массив переопределить нельзя
        //final для классов часто используется, для свойств еще чаще, для методов и для аргументов - реже
    }

    //Static свойства и методы объектам не принадлежат, они принадлежат классам
    //вызывать и обращаться можно без создания объекта
    static final double PI_NEW;//обычно константы описываются как static и final
    //static методы или обслуживающие - что-то высчитывают, либо фабричные - создают объекты
    public static int summ(int a, int b){
        return a + b;
        //из статических методов нельзя обращаться к нестатическим свойствам и методам
    }

    //статический блок - используется для работы со статическими свойствами
    //он загружается в память(выполняется) один раз - при загрузке класса в память
    static {
        PI_NEW = 3.4;
    }
}

class SomeClass{
    String name;
}
//class Child extends CalcUtils{} - выдаст ошибку, так как CalcUtils определен как final class



